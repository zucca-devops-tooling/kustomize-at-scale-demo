@Library('kyverno-parallel-apply') _

def cliVersion = "1.0.1"
def cliFile = "kustomtrace-cli-${cliVersion}-all.jar"
def cliUrl = "https://github.com/zucca-devops-tooling/kustom-trace/releases/download/v${cliVersion}/${cliFile}"
def appListFile = "apps.yaml"
def builtAppsFolder = "kustomize-output"
def policiesFile = "policies.yaml"
def kyvernoResults = "results.yaml"

pipeline {
    agent any

    environment {
        GRADLE_OPTS = '-Dorg.gradle.jvmargs="-Xmx2g -XX:+HeapDumpOnOutOfMemoryError"'
    }

    stages {
        stage('Checkout') {
            steps {
                checkout scm
            }
        }
        stage('Download kustom-trace-cli') {
            steps {
                script {
                    sh "curl -LO ${cliUrl}"
                }
            }
        }
        stage('PAUSE FOR MANUAL DEBUGGING') {
        steps {
            script {
                // Get the absolute path of the current workspace
                def workspacePath = pwd()
    
                echo "--------------------------------------------------------"
                echo "PIPELINE PAUSED - READY FOR MANUAL DEBUGGING"
                echo "--------------------------------------------------------"
                echo "The workspace will NOT be cleaned until you click 'Proceed'."
                echo ""
                echo "1. SSH into the Jenkins agent now."
                echo "2. Navigate to the workspace directory:"
                echo "   cd ${workspacePath}"
                echo "3. Run your git commands to debug the remotes:"
                echo "   git remote -v"
                echo "   git status"
                echo "--------------------------------------------------------"
    
                // This is the crucial step. It pauses the build indefinitely.
                // The pipeline will not continue to the 'post' block and will not
                // clean the workspace until you interact with it in the Jenkins UI.
                input message: 'Pipeline paused for debugging. Click "Proceed" when you are finished.'
            }
        }
    }
        stage('Get Apps to Build') {
            steps {
                script {
                    if (env.CHANGE_ID) {
                        echo "Pull Request detected. Calculating affected applications..."

                        // Define the name for the file that will hold the list of changed files.
                        def targetBranch = env.CHANGE_TARGET ?: 'main'

                        echo "Comparing against target branch: ${targetBranch}"
                        def diffOutput = sh(script: "git diff --name-status origin/${targetBranch}...HEAD", returnStdout: true).trim()

                        def changedFiles = diffOutput.readLines().collect { line ->
                            // Split the line by the tab character and take the second element (the path).
                            return line.split('\t')[1]
                        }

                        def changedFilesArg = changedFiles.join(' ')
                        echo "Found the following changed files: ${changedFilesArg}"

                        sh "java -jar ${cliFile} -a ./kubernetes -o ${appListFile} affected-apps ${changedFilesArg}"

                        echo "Affected apps list generated for PR."
                    } else {
                        echo "Main branch build detected. Getting all root applications..."

                        sh "java -jar ${cliFile} -a ./kubernetes -o ${appListFile} list-root-apps"

                        echo "Full application list generated."
                    }
                }
            }
        }
        stage('Build apps') {
            steps {
                script {
                    def apps = readYaml file: appListFile
                    sh "mkdir ${builtAppsFolder}"

                    if (apps && apps.'root-apps') {
                        apps.'root-apps'.each { appPath ->
                            def outputFile = builtAppsFolder + "/" + appPath.replaceAll("/", "_") + ".yaml"
                            echo "--- Executing build for: ${appPath} ---"
                            def buildResult = sh(
                                script: "kustomize build kubernetes/${appPath} -o ${outputFile}",
                                returnStatus: true
                            )

                            if (buildResult != 0) {
                                echo "❌ Failed to build ${appPath}, skipping..."
                            }
                        }
                    }
                }
            }
        }
        stage('Build kyverno policies') {
            steps {
                script {
                    sh "kustomize build ./policies -o ${policiesFile}"
                }
            }
        }
        stage('Add extra autogenerated resources') {
            when {
                expression {
                    branch 'main'
                }
            }
            steps {
                script {
                    sh "chmod +x generate-expensive-apps.sh"
                    sh "./generate-expensive-apps.sh"
                }
            }
        }

        stage('Apply kyverno policies') {
            steps {
                script {
                    try {
                        sh "kyverno apply ${policiesFile} --resource ${builtAppsFolder} --audit-warn --policy-report --output generated > ${kyvernoResults}"
                    } catch (e) {
                        println "Kyverno policies failed"
                    }
                }
            }
            post {
                always {
                    script {
                        if (fileExists(kyvernoResults)) {
                            archiveArtifacts artifacts: "${kyvernoResults}"
                        }
                        sh "ls generated"
                    }
                }
            }
        }
        stage('Parallel Apply') {
            when {
                expression {
                    branch 'main'
                }
            }
            steps {
                script {
                    try {
                        kyvernoParallelApply([
                            'generatedResourcesDir': 'generated',
                            'manifestSourceDirectory': builtAppsFolder,
                            'finalReportPath': kyvernoResults,
                            'policyPath': policiesFile,
                            'extraKyvernoArgs': '--audit-warn',
                            'debugLogDir': 'logs'
                        ])
                    } catch (err) {
                        println("Apply failed")
                        println(err)
                    }
                }
            }
        }
    }
    post {
        always {
            deleteDir()
        }
    }
}
